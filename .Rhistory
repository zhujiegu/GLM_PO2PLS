Reduce("+", tmp)
Reduce("+", tmp) %>% unlist %>% sum
lapply(1:level^dim, fun_h)%>% unlist %>% sum
x <- list( a = matrix(c(1,2,3,4), nc=2), b = matrix(1, nc=2, nr=2))
x
x <- list( a = matrix(c(1,2,0,4), nc=2), b = matrix(4, nc=2, nr=2))
x
Reduce("+",x)
x <- list( a = matrix(c(1,2,0,4), nc=2), b = matrix(4, nc=2, nr=2), c= matrix(1, nc=2, nr=2))
x
Reduce("+",x)
sigma = matrix(c(4,-1,-1,4),2)
level = 30
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
fun_h <- function(i){
crossprod(nodes[1, ,drop=F]) * w[i,]
}
tmp <- lapply(1:level^dim, fun_h)
Reduce("+", tmp)
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
tmp <- lapply(1:level^dim, fun_h)
Reduce("+", tmp)
sigma = matrix(c(4,-1.9,-1.9,4),2)
level = 30
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
tmp <- lapply(1:level^dim, fun_h)
Reduce("+", tmp)
fun_h <- function(i){
nodes[i, ,drop=F] * w[i,]
}
tmp <- lapply(1:level^dim, fun_h)
Reduce("+", tmp)
level = 3
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
tmp <- lapply(1:level^dim, fun_h)
Reduce("+", tmp)
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
tmp <- lapply(1:level^dim, fun_h)
Reduce("+", tmp)
mu=rep(0,dim)
mu
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl <- function(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F){
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
if(plot_nodes = T){
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
}
# # check nodes
# nw <- createNIGrid(d=2, type = "GHe", level = 10)
# print(data.frame(nodes=getNodes(nw), weights=getWeights(nw)))
# plot(nw)
# calculate each node
tmp <- lapply(1:level^dim, fun_h)
# sum over level^dim combos
result <- Reduce("+", tmp)
return(result)
}
GH_Intl <- function(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F){
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
if(plot_nodes){
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
}
# # check nodes
# nw <- createNIGrid(d=2, type = "GHe", level = 10)
# print(data.frame(nodes=getNodes(nw), weights=getWeights(nw)))
# plot(nw)
# calculate each node
tmp <- lapply(1:level^dim, fun_h)
# sum over level^dim combos
result <- Reduce("+", tmp)
return(result)
}
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
r=1
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
r=1
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
fun_h <- function(i){
print("here")
crossprod(nodes[i, ,drop=F]) * w[i,]
}
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
fun_h <- function(i){
print("here")
crossprod(nodes[i, ,drop=F]) * w[i,]
print("i=",i)
}
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
fun_h <- function(i){
print("here")
crossprod(nodes[i, ,drop=F]) * w[i,]
print(i)
}
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=3, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=3, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
nodes
tmp <- lapply(1:level^dim, fun_h)
# sum over level^dim combos
result <- Reduce("+", tmp)
result
Reduce("+", tmp)
tmp
fun_h <- function(i){
print("here")
crossprod(nodes[i, ,drop=F]) * w[i,]
}
tmp <- lapply(1:level^dim, fun_h)
# sum over level^dim combos
result <- Reduce("+", tmp)
result
level=5
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
if(plot_nodes){
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
}
tmp <- lapply(1:level^dim, fun_h)
print(2)
# sum over level^dim combos
result <- Reduce("+", tmp)
result
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=5, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=7, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
GH_Intl(fun_h, dim=2*r, level=7, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=8, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=3, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl <- function(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=F){
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
if(plot_nodes){
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
}
print(1)
# # check nodes
# nw <- createNIGrid(d=2, type = "GHe", level = 10)
# print(data.frame(nodes=getNodes(nw), weights=getWeights(nw)))
# plot(nw)
# calculate each node
print(level)
print(dim(nodes))
print(length(w))
tmp <- lapply(1:level^dim, fun_h)
print(2)
# sum over level^dim combos
result <- Reduce("+", tmp)
print(3)
return(result)
}
r=1
sigma = matrix(c(4,-1.9,-1.9,4),2)
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
GH_Intl(fun_h, dim=2*r, level=3, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=2, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=4, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=5, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=5, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
nodes
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
r=1
sigma = matrix(c(4,-1.9,-1.9,4),2)
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
dim=2*r
level=6
mu=rep(0,2*r)
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
library(mvQuad)
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# standard GH rule
myRule_GH <- function(l){
rule <- fastGHQuad::gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
# standard GH rule
myRule_GH <- function(l){
rule <- fastGHQuad::gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
library(magrittr)
# adjust for mu and sigma
nodes <- t(sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)))
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# calculate each node
tmp <- lapply(1:level^dim, fun_h)
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
# calculate each node
tmp <- lapply(1:level^dim, fun_h)
Reduce("+", tmp)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=10, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=5, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=10, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=5, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
r=1
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
r=1
sigma = matrix(c(4,-1.9,-1.9,4),2)
GH_Intl(fun_h, dim=2*r, level=10, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=10, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
# standard GH rule
myRule_GH <- function(l){
rule <- fastGHQuad::gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=dim, type = "myRule_GH", level = level)
dim=2*r
nw_myGH <- createNIGrid(d=dim, type = "myRule_GH", level = level)
level=10
nw_myGH <- createNIGrid(d=dim, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- t(sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)))
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# # check nodes
# nw <- createNIGrid(d=2, type = "GHe", level = 10)
# print(data.frame(nodes=getNodes(nw), weights=getWeights(nw)))
# plot(nw)
print(level^dim)
print(dim(nodes))
print(dim(w))
# calculate each node
tmp <- lapply(1:level^dim, fun_h)
# sum over level^dim combos
result <- Reduce("+", tmp)
result
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=10, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=10, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=9, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=11, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
r=1
sigma = matrix(c(4,-1.9,-1.9,4),2)
knitr::opts_chunk$set(echo = TRUE, fig.width = 16, fig.height = 12)
library(ggplot2)
library(tidyverse)
library(gridExtra)
library(tidyr)
library(scales)
library(magrittr)
library(latex2exp)
load('fit_simu1.RData')
data_summary <- function(x){
m <- mean(x)
sd <-sd(x)
ymin<-m-1.96*sd
ymax<-m+1.96*sd
return(c(y=m,ymin=ymin,ymax=ymax))
}
tm_plot <- function(dat, title){
ggplot(data = dat, aes(x = key, y = value, color = key))+
stat_summary(fun.data=data_summary, geom="errorbar", size=2, width=0.2) +
stat_summary(fun.data=data_summary, geom="point", size=4) +
ggtitle(title)+
theme(axis.text=element_text(size=20),
title =element_text(size=25, face='bold'),
strip.text = element_text(size = 20)) +
facet_grid(rows = vars(alpha_tu), cols = vars(alpha_z))
}
# ab$key %<>% factor(levels = c("a", "a_b", "b"))
# levels(topss$method) <- c("O2PLS", "SO2PLS", "GO2PLS")
p1 <- tm_plot(ab %>% filter(N==10000, B==1,alpha_z!=0.4,key%in%c('a_b1','a_b3')), "N=10000 (B=1)")
p2 <- tm_plot(ab %>% filter(N==100, B==1,alpha_z!=0.4, key%in%c('a_b1','a_b3')), "N=100 (B=1)")
p3 <- tm_plot(ab %>% filter(N==100, B==1,alpha_z!=0.4, key%in%c('a_b2')), "N=100 (B=1)")
# tm_plot(ab %>% filter(N==100, B==10, key !='a'), "N=100 (B=10)")
grid.arrange(p1,p2,p3, nrow=1)
knitr::opts_chunk$set(echo = TRUE, fig.width = 16, fig.height = 12)
library(ggplot2)
library(tidyverse)
library(gridExtra)
library(tidyr)
library(scales)
library(magrittr)
library(latex2exp)
load('fit_simu1.RData')
data_summary <- function(x){
m <- mean(x)
sd <-sd(x)
ymin<-m-1.96*sd
ymax<-m+1.96*sd
return(c(y=m,ymin=ymin,ymax=ymax))
}
tm_plot <- function(dat, title){
ggplot(data = dat, aes(x = key, y = value, color = key))+
stat_summary(fun.data=data_summary, geom="errorbar", size=2, width=0.2) +
stat_summary(fun.data=data_summary, geom="point", size=4) +
ggtitle(title)+
theme(axis.text=element_text(size=20),
title =element_text(size=25, face='bold'),
strip.text = element_text(size = 20)) +
facet_grid(rows = vars(alpha_tu), cols = vars(alpha_z))
}
# ab$key %<>% factor(levels = c("a", "a_b", "b"))
# levels(topss$method) <- c("O2PLS", "SO2PLS", "GO2PLS")
load('fit_simu1.RData')
setwd("~/Mygit/Scripts/SupervisedPO2PLS_simu/Results/ab_estimate/V4")
load('fit_simu1.RData')
p1 <- tm_plot(ab %>% filter(N==10000, B==1,alpha_z!=0.4,key%in%c('a_b1','a_b3')), "N=10000 (B=1)")
p2 <- tm_plot(ab %>% filter(N==100, B==1,alpha_z!=0.4, key%in%c('a_b1','a_b3')), "N=100 (B=1)")
p3 <- tm_plot(ab %>% filter(N==100, B==1,alpha_z!=0.4, key%in%c('a_b2')), "N=100 (B=1)")
# tm_plot(ab %>% filter(N==100, B==10, key !='a'), "N=100 (B=10)")
grid.arrange(p1,p2,p3, nrow=1)
# tm_plot(ab %>% filter(N==100, B==10, key !='a'), "N=100 (B=10)")
grid.arrange(p1,p2,p3, nrow=1)
# tm_plot(ab %>% filter(N==100, B==10, key !='a'), "N=100 (B=10)")
grid.arrange(p1,p2,p3, nrow=1)
p1 <- tm_plot(ab %>% filter(N==10000, B==1, key%in%c('b1','b3'), alpha_tu!=0.001), "N=10000 (B=1)")
p2 <- tm_plot(ab %>% filter(N==100, B==1, key%in%c('b1','b3'), alpha_tu!=0.001), "N=100 (B=1)")
# tm_plot(ab %>% filter(N==100, B==10, key !='a'), "N=100 (B=10)")
grid.arrange(p1,p2, nrow=1)
source("~/Mygit/Supervised_PO2PLS/Numerical_int.R")
