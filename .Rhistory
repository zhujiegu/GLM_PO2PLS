weights <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
pts <- list(nodes=nodes,weights=weights)
plot(pts$nodes, cex=-5/log(pts$weights), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
nw <- createNIGrid(d=2, type = "GHe", level = 10)
# rescale grid for desired domainmatrix(c(4,0.,0,4),2)
rescale(nw, m = c(0,0), C = sigma, dec.type = 2) #type 2 is Cholesky decomposition
plot(nw)
print(data.frame(nodes=getNodes(nw), weights=getWeights(nw)))
weights
print(data.frame(nodes=getNodes(nw), weights=getWeights(nw)))
pts$nodes
pts$nodes
sapply(pts$nodes, sum)
sapply(pts$nodes, rowSum)
sapply(pts$nodes, rowsum)
sapply(pts$nodes, print)
sapply(pts$nodes, t)
apply(pts$nodes,1,sum)
pts$nodes %>% head
lapply(pts$nodes,sum)
nodes
as.list(nodes)
as.list(data.frame(t(nodes)))
nodes_list <- as.list(data.frame(t(nodes)))
weights
nodes_list <- list(node=as.list(data.frame(t(nodes))), w=as.list(weights))
nodes_list %>% head
nodes_list <- as.list(nodes = data.frame(t(nodes)), w = as.list(weights))
lapply(1:level^dim, print)
lapply(1:level^dim, print) %>% unlist
lapply(1:level^dim, print) %>% unlist %>% sum
lapply(1:level^dim, print) %>% unlist %>% sum
GH_appr <- lapply(1:level^dim, print) %>% unlist %>% sum
GH_appr
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
fun_h <- function(i){
crossprod(nodes[,i])
}
GH_appr <- lapply(1:level^dim, fun_h) %>% unlist %>% sum
1:level^dim
1:level^dim
fun_h(1)
fun_h(2)
fun_h(3)
nodes
fun_h <- function(i){
crossprod(nodes[i,])
}
GH_appr <- lapply(1:level^dim, fun_h) %>% unlist %>% sum
GH_appr
fun_h <- function(i){
crossprod(nodes[i,]) * w[i,]
}
lapply(1:level^dim, fun_h) %>% unlist %>% sum
lapply(1:level^dim, fun_h)
crossprod(nodes[1,])
nodes[1,]
nodes[1,,drop=F]
crossprod(nodes[1, ,drop=F]) * w[i,]
fun_h <- function(i){
crossprod(nodes[1, ,drop=F]) * w[i,]
}
lapply(1:level^dim, fun_h)
?map
tmp <- lapply(1:level^dim, fun_h) %>% unlist %>% sum
do.call(sum, tmp)
tmp
tmp <- lapply(1:level^dim, fun_h) %>% unlist %>% sum
tmp <- lapply(1:level^dim, fun_h)
do.call(sum, tmp)
tmp
reduce("+", tmp)
Reduce("+", tmp)
Reduce("+", tmp) %>% unlist %>% sum
lapply(1:level^dim, fun_h)%>% unlist %>% sum
x <- list( a = matrix(c(1,2,3,4), nc=2), b = matrix(1, nc=2, nr=2))
x
x <- list( a = matrix(c(1,2,0,4), nc=2), b = matrix(4, nc=2, nr=2))
x
Reduce("+",x)
x <- list( a = matrix(c(1,2,0,4), nc=2), b = matrix(4, nc=2, nr=2), c= matrix(1, nc=2, nr=2))
x
Reduce("+",x)
sigma = matrix(c(4,-1,-1,4),2)
level = 30
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
fun_h <- function(i){
crossprod(nodes[1, ,drop=F]) * w[i,]
}
tmp <- lapply(1:level^dim, fun_h)
Reduce("+", tmp)
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
tmp <- lapply(1:level^dim, fun_h)
Reduce("+", tmp)
sigma = matrix(c(4,-1.9,-1.9,4),2)
level = 30
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
tmp <- lapply(1:level^dim, fun_h)
Reduce("+", tmp)
fun_h <- function(i){
nodes[i, ,drop=F] * w[i,]
}
tmp <- lapply(1:level^dim, fun_h)
Reduce("+", tmp)
level = 3
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
tmp <- lapply(1:level^dim, fun_h)
Reduce("+", tmp)
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
tmp <- lapply(1:level^dim, fun_h)
Reduce("+", tmp)
mu=rep(0,dim)
mu
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl <- function(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F){
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
if(plot_nodes = T){
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
}
# # check nodes
# nw <- createNIGrid(d=2, type = "GHe", level = 10)
# print(data.frame(nodes=getNodes(nw), weights=getWeights(nw)))
# plot(nw)
# calculate each node
tmp <- lapply(1:level^dim, fun_h)
# sum over level^dim combos
result <- Reduce("+", tmp)
return(result)
}
GH_Intl <- function(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F){
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
if(plot_nodes){
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
}
# # check nodes
# nw <- createNIGrid(d=2, type = "GHe", level = 10)
# print(data.frame(nodes=getNodes(nw), weights=getWeights(nw)))
# plot(nw)
# calculate each node
tmp <- lapply(1:level^dim, fun_h)
# sum over level^dim combos
result <- Reduce("+", tmp)
return(result)
}
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
r=1
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
r=1
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
fun_h <- function(i){
print("here")
crossprod(nodes[i, ,drop=F]) * w[i,]
}
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
fun_h <- function(i){
print("here")
crossprod(nodes[i, ,drop=F]) * w[i,]
print("i=",i)
}
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
fun_h <- function(i){
print("here")
crossprod(nodes[i, ,drop=F]) * w[i,]
print(i)
}
GH_Intl(fun_h, dim=2*r, level=6, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=3, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=3, tu, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
nodes
tmp <- lapply(1:level^dim, fun_h)
# sum over level^dim combos
result <- Reduce("+", tmp)
result
Reduce("+", tmp)
tmp
fun_h <- function(i){
print("here")
crossprod(nodes[i, ,drop=F]) * w[i,]
}
tmp <- lapply(1:level^dim, fun_h)
# sum over level^dim combos
result <- Reduce("+", tmp)
result
level=5
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
if(plot_nodes){
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
}
tmp <- lapply(1:level^dim, fun_h)
print(2)
# sum over level^dim combos
result <- Reduce("+", tmp)
result
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=5, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=7, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
GH_Intl(fun_h, dim=2*r, level=7, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=8, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=3, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl <- function(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=F){
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# visulize the nodes
if(plot_nodes){
plot(nodes, cex=-5/log(w), pch=19,
xlab=expression(x[1]),
ylab=expression(x[2]))
}
print(1)
# # check nodes
# nw <- createNIGrid(d=2, type = "GHe", level = 10)
# print(data.frame(nodes=getNodes(nw), weights=getWeights(nw)))
# plot(nw)
# calculate each node
print(level)
print(dim(nodes))
print(length(w))
tmp <- lapply(1:level^dim, fun_h)
print(2)
# sum over level^dim combos
result <- Reduce("+", tmp)
print(3)
return(result)
}
r=1
sigma = matrix(c(4,-1.9,-1.9,4),2)
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
GH_Intl(fun_h, dim=2*r, level=3, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=2, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=4, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=5, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=5, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
nodes
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
r=1
sigma = matrix(c(4,-1.9,-1.9,4),2)
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
dim=2*r
level=6
mu=rep(0,2*r)
# standard GH rule
myRule_GH <- function(l){
rule <- gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
library(mvQuad)
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# standard GH rule
myRule_GH <- function(l){
rule <- fastGHQuad::gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
# standard GH rule
myRule_GH <- function(l){
rule <- fastGHQuad::gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=2, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)) %>% t
library(magrittr)
# adjust for mu and sigma
nodes <- t(sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)))
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# calculate each node
tmp <- lapply(1:level^dim, fun_h)
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
# calculate each node
tmp <- lapply(1:level^dim, fun_h)
Reduce("+", tmp)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=10, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=5, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=10, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=6, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=5, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
r=1
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
fun_h <- function(i){
crossprod(nodes[i, ,drop=F]) * w[i,]
}
r=1
sigma = matrix(c(4,-1.9,-1.9,4),2)
GH_Intl(fun_h, dim=2*r, level=10, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=10, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
# standard GH rule
myRule_GH <- function(l){
rule <- fastGHQuad::gaussHermiteData(l)
n <- rule$x
w <- rule$w
initial.domain <- matrix(c(-Inf, Inf), ncol=2)
return(list(n=as.matrix(n), w=as.matrix(w), features=list(initial.domain=initial.domain)))
}
nw_myGH <- createNIGrid(d=dim, type = "myRule_GH", level = level)
dim=2*r
nw_myGH <- createNIGrid(d=dim, type = "myRule_GH", level = level)
level=10
nw_myGH <- createNIGrid(d=dim, type = "myRule_GH", level = level)
# adjust for mu and sigma
nodes <- t(sqrt(2)*t(chol(sigma))%*%t(getNodes(nw_myGH)))
w <- (1/sqrt(pi))^dim *getWeights(nw_myGH)
# # check nodes
# nw <- createNIGrid(d=2, type = "GHe", level = 10)
# print(data.frame(nodes=getNodes(nw), weights=getWeights(nw)))
# plot(nw)
print(level^dim)
print(dim(nodes))
print(dim(w))
# calculate each node
tmp <- lapply(1:level^dim, fun_h)
# sum over level^dim combos
result <- Reduce("+", tmp)
result
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
source('~/Mygit/Supervised_PO2PLS/Numerical_int.R')
GH_Intl(fun_h, dim=2*r, level=10, mu=rep(0,2*r), sigma=sigma, plot_nodes=T)
GH_Intl(fun_h, dim=2*r, level=10, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=9, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
GH_Intl(fun_h, dim=2*r, level=11, mu=rep(0,2*r), sigma=sigma, plot_nodes=F)
r=1
sigma = matrix(c(4,-1.9,-1.9,4),2)
