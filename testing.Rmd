---
title: "Supervised PO2PLS"
author: "Gabriel N-L"
date: "20/01/2020"
output: html_document
---

```{r}
set.seed(1)
require(matrixcalc)
```

Before beginning to create / test the EM algorithm, I will take a subset of the RNA-seq dataset to test on. I will also create a binary vector for the outcome. 
```{r}
data <- load("~/Desktop/Thesis/pre_o2pls.RData")

z <- matrix(0, nrow = 23, ncol = 1)
z[11:23,] <- 1

test_x <- x[ , 1:15]
test_y <- y[ , 1:20]
colnames(test_x) <- NULL
rownames(test_x) <- NULL
colnames(test_y) <- NULL
rownames(test_y) <- NULL

p <- ncol(test_x)
q <- ncol(test_y)
r <- 1
rx <- 1
ry <- 1
N <- nrow(test_x)
```

Generate 'true' params:
```{r}
pars <- PO2PLS::generate_params(X = test_x, Y = test_y, r = 1, rx = 1, ry = 1, type = "o2m")

a <- matrix(rnorm(r), nrow = r, ncol = 1)
b <- matrix(rnorm(r), nrow = r, ncol = 1)
sig2g <- 0.5
sig2h <- 0.5
SigU = pars$SigT%*%pars$B^2 + sig2h*diag(r)

(params <- list(W = pars$W, Ws = pars$Wo, C = pars$C, Cs = pars$Co, B = pars$B, a = a, b = b, SigT = pars$SigT, SigTs = pars$SigTo, SigU = SigU, SigUs = pars$SigUo, sig2e = pars$sig2E, sig2f = pars$sig2F, sig2g = sig2g, sig2h = sig2h))
```
Generate data: 
```{r}
Gamma <- rbind(cbind(params$W, matrix(0,p,r), params$Ws, matrix(0,p,ry)),
                cbind(matrix(0,q,r), params$C, matrix(0,q,rx), params$Cs),
              cbind(t(params$a), t(params$b), matrix(0,1,(rx+ry))))

VarZ = PO2PLS::blockm(
  PO2PLS::blockm(
    PO2PLS::blockm(params$SigT, params$SigT%*%params$B, params$SigU),
    matrix(0,2*r,rx), params$SigTs),
  matrix(0,2*r+rx,ry), params$SigUs)


dat <- MASS::mvrnorm(n = N,
              mu = rep(0,p+q+1),
              Sigma = Gamma %*% VarZ %*% t(Gamma) +
                diag(rep(c(params$sig2e,params$sig2f, params$sig2g),c(p,q,1))))
x_gen = dat[,1:p]
y_gen = dat[,((p+1):(p+q))]
z_gen <- dat[, (p+q+1)]
#list(x_gen, y_gen, z_gen)
```


Starting off with an initial guess for the parameters: these will be updated via the EM algorithm. 
```{r}
W <- matrix(rnorm(p*r), nrow = p, ncol = r)
Ws <- matrix(rnorm(p*rx), nrow = p, ncol = rx)
C <- matrix(rnorm(q*r), nrow = q, ncol = r)
Cs <- matrix(rnorm(q*ry), nrow = q, ncol = ry)
B <- diag(sort(abs(rnorm(r))), nrow = r) # sort for first comp, abs for sign, nrow=r for r=1
a <- matrix(rnorm(r), nrow = r, ncol = 1)
b <- matrix(rnorm(r), nrow = r, ncol = 1)
SigT <- diag(sort(abs(rnorm(r))), nrow = r)
SigTs <- diag(sort(abs(rnorm(rx))), nrow = rx)
SigUs <- diag(sort(abs(rnorm(ry))), nrow = ry)
sig2e <- 1
sig2f <- 1
sig2g <- 1
sig2h <- 1
SigU = SigT%*%B^2 + sig2h*diag(r)


params_current <- list(W = W, Ws = Ws, C = C, Cs = Cs, B = B, a = a, b = b, SigT = SigT, SigTs = SigTs, SigU = SigU, SigUs = SigUs, sig2e = sig2e, sig2f = sig2f, sig2g = sig2g, sig2h = sig2h)
params_init <- params_current
```



```{r}
e_step_W <- function (x, y, z, params_current){
  #extract the parameters 
  W <- params_current$W
  Ws <- params_current$Ws
  C <- params_current$C
  Cs <- params_current$Cs
  B <- params_current$B
  a <- params_current$a
  b <- params_current$b
  SigT <- params_current$SigT
  SigTs <- params_current$SigTs
  SigU <- params_current$SigU
  SigUs <- params_current$SigUs
  sig2e <- params_current$sig2e
  sig2f <- params_current$sig2f
  sig2g<- params_current$sig2g
  
  #dimensions
  N <- nrow(x)
  p <- nrow(W)
  q <- nrow(C)
  r <- ncol(W)
  rx <- ncol(Ws)
  ry <- ncol(Cs)
  
  #concatenated data matrix, required for each of the conditional expectations in the e step: 
  xyz <- cbind(x, y, z)
  
  #general covariance matrix Sigma (p+q+1)x(p+q+1): needs to be inverted. This will currently take a lot of time if the following method is used
  Sig_top <- cbind(W%*%SigT%*%t(W) + Ws%*%SigTs%*%t(Ws) + sig2e*diag(p), W%*%SigT%*%B%*%t(C), W%*%SigT%*%a + W%*%SigT%*%B%*%b)
  Sig_mid <- cbind(C%*%B%*%SigT%*%t(W), C%*%SigU%*%t(C) + Cs%*%SigUs%*%t(Cs) + sig2f*diag(q), C%*%SigT%*%B%*%a + C%*%SigU%*%b)
  Sig_bot <- cbind(t(a)%*%SigT%*%t(W) + t(b)%*%B%*%SigT%*%t(W), t(a)%*%B%*%SigT%*%t(C) + t(b)%*%SigU%*%t(C), t(a)%*%SigU%*%a + t(b)%*%SigU%*%b + 2*t(a)%*%B%*%SigT%*%b + sig2g)
  Sig <- rbind(Sig_top, Sig_mid, Sig_bot)
  invSig <- solve(Sig)
  
  #the other covariances needed to derive the conditional expectations
  cov_xyz_t <- rbind(W%*%SigT, C%*%B%*%SigT, t(a)%*%SigT + t(b)%*%SigT%*%B)
  mu_t <- xyz%*%invSig%*%cov_xyz_t
  
  #similarly, for mu_ts
  cov_xyz_ts <- rbind(Ws%*%SigTs, matrix(0, nrow = q+1, ncol = rx))
  mu_ts <- xyz%*%invSig%*%cov_xyz_ts
  
  #mu_u
  cov_xyz_u <- rbind(W%*%SigT%*%B, C%*%SigU, t(a)%*%SigT%*%B + t(b)%*%SigU)
  mu_u <- xyz%*%invSig%*%cov_xyz_u
  
  #mu_us
  cov_xyz_us <- rbind(matrix(0, nrow = p, ncol = ry), Cs%*%SigUs, matrix(0, nrow = 1, ncol = ry))
  mu_us <- xyz%*%invSig%*%cov_xyz_us
  
  #now for the rest
  S_tt <- SigT - t(cov_xyz_t)%*%invSig%*%cov_xyz_t + crossprod(mu_t) / N
  S_tt <- S_tt * N
  
  S_tts <-  -t(cov_xyz_t)%*%invSig%*%cov_xyz_ts  + crossprod(mu_t, mu_ts) / N
  S_tts <- S_tts * N
  
  S_tsts <- SigTs - t(cov_xyz_ts)%*%invSig%*%cov_xyz_ts + crossprod(mu_ts) / N
  S_tsts <- S_tsts * N
  
  S_uu <- SigU - t(cov_xyz_u)%*%invSig%*%cov_xyz_u + crossprod(mu_u) / N
  S_uu <- S_uu * N
  
  S_uus <- -t(cov_xyz_u)%*%invSig%*%cov_xyz_us + crossprod(mu_u, mu_us) / N
  S_uus <- S_uus * N
  
  S_usus <- SigUs - t(cov_xyz_us)%*%invSig%*%cov_xyz_us + crossprod(mu_us) / N
  S_usus <- S_usus * N
  
  S_tu <- SigT%*%B - t(cov_xyz_t)%*%invSig%*%cov_xyz_u + crossprod(mu_t, mu_u) / N
  S_tu <- S_tu * N


  loglik = N*(p+q+1)*log(2*pi) + N*log(det(Sig)) + matrix.trace(crossprod(xyz)%*%invSig)
  loglik = -loglik/2
  
  return(list(mu_t = mu_t, mu_ts = mu_ts, mu_u = mu_u, mu_us = mu_us, S_tt = S_tt, S_tts = S_tts, S_tsts = S_tsts, S_uu = S_uu, S_uus = S_uus, S_usus = S_usus, S_tu = S_tu, logl = loglik))
}

```


M step: here, I will try out the M step. 
```{r}
m_step_W <- function (e_step_W, x, y, z, params_current) {
  #e_step_W is the output (List) from implementing the e-step, i.e. e_step_W <- e_step(...), and estimating the various required conditional expectations
  #retrieve parameters
  W <- params_current$W
  Ws <- params_current$Ws
  C <- params_current$C
  Cs <- params_current$Cs
  B <- params_current$B
  a <- params_current$a
  b <- params_current$b
  SigT <- params_current$SigT
  SigTs <- params_current$SigTs
  SigU <- params_current$SigU
  SigUs <- params_current$SigUs
  sig2e <- params_current$sig2e
  sig2f <- params_current$sig2f
  sig2g<- params_current$sig2g
  p <- nrow(W)
  q <- nrow(C)
  # the m step for W, Ws and sigma2e requires the following conditional expectations: 
  mu_t <- e_step_W$mu_t
  mu_ts <- e_step_W$mu_ts
  mu_u <- e_step_W$mu_u
  mu_us <- e_step_W$mu_us
  S_tt <- e_step_W$S_tt
  S_tts <- e_step_W$S_tts
  S_tsts <- e_step_W$S_tsts
  S_uu <- e_step_W$S_uu
  S_uus <- e_step_W$S_uus
  S_usus <- e_step_W$S_usus
  S_tu <- e_step_W$S_tu
  
  #now calculate the maximum likelihood estimates for W, Ws and sigma2e
  W_hat <- OmicsPLS::orth( (t(x) %*% mu_t - Ws %*% t(S_tts)) ) #%*% MASS::ginv(S_tt)
  #cat(c(crossprod(W_hat, params$W)), " ** ")
  
  # #does this need to be W in here or W_hat???
  Ws_hat <- OmicsPLS::orth( (t(x) %*% mu_ts - W_hat %*% S_tts) ) #%*% MASS::ginv(S_tsts)
  #cat(c(crossprod(Ws_hat, params$Ws)), " ** ")
  
  sig2e_hat <- matrix.trace(t(x)%*%x -2*t(x) %*% mu_t %*% t(W_hat) -2*t(x)%*%mu_ts %*% t(Ws_hat) + W_hat %*% S_tt %*% t(W_hat) + 2*W_hat %*% S_tts %*% t(Ws_hat) + Ws_hat %*% S_tsts %*% t(Ws_hat)) / p
  
  C_hat <- OmicsPLS::orth( (t(y) %*% mu_u - Cs %*% t(S_uus)) ) #%*% MASS::ginv(S_uu)
  #cat(c(crossprod(C_hat, params$C)), " ** ")
  
  # #does this need to be C in here or C_hat??? C_hat
  Cs_hat <- OmicsPLS::orth( (t(y) %*% mu_us - C_hat %*% S_uus) ) #%*% MASS::ginv(S_usus)
  #cat(c(crossprod(Cs_hat, params$Cs)), " ** ")
  
  sig2f_hat <- matrix.trace(t(y)%*%y -2*t(y) %*% mu_u %*% t(C_hat) -2*t(y)%*%mu_us %*% t(Cs_hat) + C_hat %*% S_uu %*% t(C_hat) + 2*C_hat %*% S_uus %*% t(Cs_hat) + Cs_hat %*% S_usus %*% t(Cs_hat)) / q
  
  a_hat <- OmicsPLS::orth( (t(mu_t)%*%z - S_tu%*%b) ) #%*% MASS::ginv(S_tt)
  #cat(c(crossprod(a_hat, params$a)), " ** ")
  
  b_hat <- OmicsPLS::orth( (t(mu_u)%*%z - t(S_tu)%*%a_hat) ) #%*% MASS::ginv(S_uu)
  #cat(c(crossprod(b_hat, params$b)), " ** ")
  
  sig2g_hat <- matrix.trace(t(z)%*%z - 2*t(z)%*%mu_t%*%a_hat - 2*t(z)%*%mu_u%*%b_hat + t(a_hat)%*%S_tt%*%a_hat + t(b_hat)%*%S_uu%*%b_hat + 2*t(a_hat)%*%S_tu%*%b_hat)
  
  B_hat <- t(S_tu) %*% solve(S_tt) * diag(1,r)
  cat(B_hat, " ** ")
  cat(c((B_hat - params$B)), " ** ")
  cat(S_tu, S_tt, " ** ")
  cat("\n")
  
  sig2h_hat <- matrix.trace(t(mu_u)%*%mu_u - 2*t(mu_u)%*%mu_t%*%B_hat + t(B_hat)%*%S_tt%*%B_hat) / r
  
  #SigT_hat <- var(mu_t)
  SigT_hat <- S_tt
  
  #here i have used all the new values to calculate SigU_hat
  SigU_hat <- SigT_hat%*%B_hat^2 + sig2h_hat*diag(r)
  
  #SigTs_hat <- var(mu_ts)
  SigTs_hat <- S_tsts
  
  #SigUs_hat <- var(mu_us)
  SigUs_hat <- S_usus
  
  # return(list(W_hat = W_hat, Ws_hat = Ws_hat, C_hat = C_hat, Cs_hat = Cs_hat, B_hat = B_hat, a_hat = a_hat, b_hat = b_hat, SigT_hat = SigT, sigTs_hat = SigTs, SigU_hat = SigU, SigUs_hat = SigUs, sig2e_hat = sig2e, sig2f_hat = sig2f, sig2g_hat = sig2g, sig2h_hat = sig2h))
  # }
  return(list(W_hat = W, Ws_hat = Ws, C_hat = C, Cs_hat = Cs, B_hat = B_hat, a_hat = a, b_hat = b, SigT_hat = SigT, SigTs_hat = SigTs, SigU_hat = SigU, SigUs_hat = SigUs, sig2e_hat = sig2e, sig2f_hat = sig2f, sig2g_hat = sig2g, sig2h_hat = sig2h))
}
# return(list(W = W_hat, Ws = Ws_hat, C = C_hat, Cs = Cs_hat, B = B_hat, a = a_hat, b = b_hat, SigT = SigT_hat, sigTs = SigTs_hat, SigU = SigU_hat, SigUs = SigUs_hat, sig2e = sig2e_hat, sig2f = sig2f_hat, sig2g = sig2g_hat, sig2h = sig2h_hat))
# }

```


```{r}
EM <- function(x, y, z, params_current, iterations){
  logl <- NA*(1:iterations)
  for (i in 1:iterations){
    E <- e_step_W(x=x, y=y, z=z, params_current = params_current)
    M <- m_step_W(e_step_W = E, x=x, y=y, z=z, params_current = params_current)
    logl[i] <- E$logl
    #params_relevant <- list(W = params_current[[1]], Ws = params_current[[2]], sigma2e = params_current[[12]])
    
    for (i in 1:length(params_current)){
      if (all.equal(M[[i]], params_current[[i]])==TRUE){
        (params_current[[i]] <- params_current[[i]])
      } else {
        params_current[[i]] <- M[[i]]
      }}
  }
  return(list(params_est = params_current, loglik = logl))
}

fit <- EM(x = x_gen, y = y_gen, z = z_gen, params_current = params_init, iterations = 20)
diff(fit$loglik) 
```

Testing a different EM function:
```{r}
# EM_new <- function(x, y, z, params_current, iterations){
#   logl <- NA*(1:iterations)
#   for (i in 1:iterations){
#     E <- e_step_W(x=x, y=y, z=z, params_current = params_current)
#     M <- m_step_W(e_step_W = E, x=x, y=y, z=z, params_current = params_current)
#     logl[i] <- E$logl
#     if 
#       
#   }
#   return(list(params_est = params_current, loglik = logl))
# }
# 
# 
# fit_new <- EM_new(x = test_x, y = test_y, z = z, params_current = params_init, iterations = 50)
```

##TESTING THE EM FUNCTION(S)
via the log-likelihood (should be monotonically increasing).
```{r}
E <- e_step_W(x = test_x, y = test_y, z = z, params_current = params_init)
M <- m_step_W(e_step_W = E, x = test_x, y = test_y, z = z, params_current = params_init)

M
params_init
diff(fit$loglik) 
any(diff(fit$loglik) < 0)
```
via comparing the estimated parameters with the (real) generated ones. 
```{r}
fit1 <- EM(x = x_gen, y = y_gen, z = z_gen, params_current = params_init, iterations = 50)
diff(fit1$loglik)
fit1$loglik

fit1$params_est$W

all.equal(fit1$params_est$W, params$W)

all.equal(fit1$params_est$Ws, params$Ws)

crossprod(fit1$params_est$W, params$W)

max(abs(crossprod(fit1$params_est$C, params$C)))
```

```{r}
testing <- function(true, pred){
  c(
    W = max(abs(crossprod(true$W,pred$W))),
    C = max(abs(crossprod(true$C,pred$C))),
    Ws = max(abs(crossprod(true$Ws,pred$Ws))),
    Cs = max(abs(crossprod(true$Cs,pred$Cs))),
    varTs_T = sum(diag(true$SigTs))/sum(diag(true$SigT))/ncol(true$Ws)*ncol(true$W),
    varUs_U = sum(diag(true$SigUs))/sum(diag(true$SigT%*%true$B+true$SigH))/ncol(true$Cs)*ncol(true$C),
    varU_T = sum(diag(true$SigT%*%true$B+true$SigH))/sum(diag(true$SigT))
  )
}
```

